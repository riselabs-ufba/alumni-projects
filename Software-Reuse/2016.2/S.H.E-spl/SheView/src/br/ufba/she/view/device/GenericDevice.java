package br.ufba.she.view.device;

import br.ufba.she.model.mqtt.*;
import br.ufba.she.utils.JsonDecode;


/***
 * Classe da camada de apresentação resposável por exibir dados dos sensores. 
 * O leiaute dos apresentação dos dados são motando em tempo de execução para 
 * cada sensor.
 * @author Edilton
 */
public class GenericDevice extends javax.swing.JInternalFrame {
    private String message = null;
    private DriverMqtt driver;
    MqttListener callback;
    
    /**
     * Creates new form ContactEditor
     */
    public GenericDevice() {
        initComponents();
    }
    
    /***
     * 
     * @param message String no formato JSON.
     */
    public GenericDevice(String message){
        this();
        this.message = message;
        this.montaTela();
    }
    
    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        buttonGroup1 = new javax.swing.ButtonGroup();
        devicePanel = new javax.swing.JPanel();
        deviceTypeLabel = new javax.swing.JLabel();
        deviceModelLabel = new javax.swing.JLabel();
        deviceTypeText = new javax.swing.JTextField();
        deviceModelText = new javax.swing.JTextField();
        deviceNameLabel = new javax.swing.JLabel();
        deviceNameText = new javax.swing.JTextField();
        deviceDataPanel = new javax.swing.JPanel();
        jScrollPane1 = new javax.swing.JScrollPane();
        deviceValueTable = new javax.swing.JTable();

        setDefaultCloseOperation(javax.swing.WindowConstants.DISPOSE_ON_CLOSE);
        setTitle("Device");
        setVisible(true);

        devicePanel.setBorder(javax.swing.BorderFactory.createTitledBorder("Device"));

        deviceTypeLabel.setText("Type:");

        deviceModelLabel.setText("Model:");

        deviceTypeText.setEditable(false);

        deviceModelText.setEditable(false);

        deviceNameLabel.setText("Name:");

        deviceNameText.setEditable(false);

        org.jdesktop.layout.GroupLayout devicePanelLayout = new org.jdesktop.layout.GroupLayout(devicePanel);
        devicePanel.setLayout(devicePanelLayout);
        devicePanelLayout.setHorizontalGroup(
            devicePanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(devicePanelLayout.createSequentialGroup()
                .add(22, 22, 22)
                .add(devicePanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.TRAILING)
                    .add(deviceNameLabel)
                    .add(deviceTypeLabel))
                .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                .add(devicePanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
                    .add(devicePanelLayout.createSequentialGroup()
                        .add(deviceTypeText)
                        .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                        .add(deviceModelLabel)
                        .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                        .add(deviceModelText))
                    .add(deviceNameText))
                .addContainerGap())
        );
        devicePanelLayout.setVerticalGroup(
            devicePanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(devicePanelLayout.createSequentialGroup()
                .add(devicePanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.BASELINE)
                    .add(deviceTypeLabel)
                    .add(deviceModelText, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                    .add(deviceTypeText, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                    .add(deviceModelLabel))
                .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                .add(devicePanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.BASELINE)
                    .add(deviceNameLabel)
                    .add(deviceNameText, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))
                .addContainerGap(org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );

        deviceTypeLabel.getAccessibleContext().setAccessibleName("Device Type:");

        deviceDataPanel.setBorder(javax.swing.BorderFactory.createTitledBorder("Device Data"));

        deviceValueTable.setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(0, 0, 0)));
        deviceValueTable.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {
                {null, null, null}
            },
            new String [] {
                "", "", ""
            }
        ) {
            Class[] types = new Class [] {
                java.lang.String.class, java.lang.String.class, java.lang.String.class
            };

            public Class getColumnClass(int columnIndex) {
                return types [columnIndex];
            }
        });
        deviceValueTable.setEnabled(false);
        jScrollPane1.setViewportView(deviceValueTable);

        org.jdesktop.layout.GroupLayout deviceDataPanelLayout = new org.jdesktop.layout.GroupLayout(deviceDataPanel);
        deviceDataPanel.setLayout(deviceDataPanelLayout);
        deviceDataPanelLayout.setHorizontalGroup(
            deviceDataPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(jScrollPane1, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 276, Short.MAX_VALUE)
        );
        deviceDataPanelLayout.setVerticalGroup(
            deviceDataPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(deviceDataPanelLayout.createSequentialGroup()
                .addContainerGap()
                .add(jScrollPane1, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 47, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );

        org.jdesktop.layout.GroupLayout layout = new org.jdesktop.layout.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(layout.createSequentialGroup()
                .addContainerGap()
                .add(layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
                    .add(devicePanel, 0, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .add(org.jdesktop.layout.GroupLayout.TRAILING, deviceDataPanel, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(layout.createSequentialGroup()
                .addContainerGap(org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .add(devicePanel, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                .add(deviceDataPanel, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents
    
    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            javax.swing.UIManager.LookAndFeelInfo[] installedLookAndFeels=javax.swing.UIManager.getInstalledLookAndFeels();
            for (int idx=0; idx<installedLookAndFeels.length; idx++)
                if ("Nimbus".equals(installedLookAndFeels[idx].getName())) {
                    javax.swing.UIManager.setLookAndFeel(installedLookAndFeels[idx].getClassName());
                    break;
                }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(GenericDevice.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(GenericDevice.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(GenericDevice.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(GenericDevice.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(() -> {
            new GenericDevice().setVisible(true);
        });
    }
    
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.ButtonGroup buttonGroup1;
    private javax.swing.JPanel deviceDataPanel;
    private javax.swing.JLabel deviceModelLabel;
    private javax.swing.JTextField deviceModelText;
    private javax.swing.JLabel deviceNameLabel;
    private javax.swing.JTextField deviceNameText;
    private javax.swing.JPanel devicePanel;
    private javax.swing.JLabel deviceTypeLabel;
    private javax.swing.JTextField deviceTypeText;
    private javax.swing.JTable deviceValueTable;
    private javax.swing.JScrollPane jScrollPane1;
    // End of variables declaration//GEN-END:variables
    
    /***
     * Formata a tabela de dados da tela e popula os dados coletados.
     * @param data Array de dados que será exibido em cada coluna.
     * @param keys Array de keys que será utilizada como título de cada coluna.
     */
    public void tableFormat(String[] data, String[] keys){
        Object [][] object = columnFormat(data);
        
        // Defini o tipo de dados das colunas.
        Class[] typesColumnClass = new Class [keys.length];
        for(int i=0;i< typesColumnClass.length;i++){
            // define o tipo de dado da colunas como String.
            typesColumnClass[i] = java.lang.String.class;
        }
        
        // object = aos dados coletados pelo device e keys são os títulos da tabela.
        deviceValueTable.setModel(new javax.swing.table.DefaultTableModel(object, keys) {
            Class[] types = typesColumnClass; //Atribui a array para definir os tipos de dados da clouna.

            @Override
            public Class getColumnClass(int columnIndex) {
                return types [columnIndex];
            }
        });    
    }
    
    /***
     * Método utilizado para formatar as colunas de dados da .
     * @param data são os dados coletados do sensor.
     * @return retorna uma array de objec.
     */
    private Object[][] columnFormat(String[] data){
        Object[][] object = null;
                
        if(data !=null && data.length >0){
            // A tabela possui apenas uma linha e o numero de colunas é igual ao size do arrya data.
            object = new Object[1][data.length];
            for(int i = 0; i < data.length; i++){
                object[0][i] = data[i];
            }             
        }
        
        return object;
    }
    
    /***
     * Método utilizado para ontar a tela.
     */
    private void montaTela(){
        
        JsonDecode jsonDecode = new JsonDecode();  
        // Pega as propriedade do device.
        jsonDecode.decodePropertyDevice(this.message);
        // Atribui o nome do device ao titúlo da tela.
        this.setTitle("Device: " + jsonDecode.getName());
        // Preenche a tela com os dados das propriedades do device.
        deviceTypeText.setText(jsonDecode.getTypeDevice());
        deviceModelText.setText(jsonDecode.getModel());
        deviceNameText.setText(jsonDecode.getName());
        
        callback = new ScreenMqttListener(this);
        // Cria um driver para o objeto, para atualizar os valores
        driver = new DriverMqtt.DriverMqttBuilder().callback(callback).topicListener(jsonDecode.getName()).build(jsonDecode.getName());
        
        // Pega os dados lidos pelo device.
        String[] keys = jsonDecode.getKeys(this.message);
        String[] values = jsonDecode.getValues(keys,this.message);
        // Formta a tebela e popula com os dados do device. 
        this.tableFormat(values,keys);
    }    
     public void atualizaTela(){
        
        JsonDecode jsonDecode = new JsonDecode();  
        // Pega as propriedade do device.
        jsonDecode.decodePropertyDevice(this.message);
        // Pega os dados lidos pelo device.
        String[] keys = jsonDecode.getKeys(this.message);
        String[] values = jsonDecode.getValues(keys,this.message);
        // Formta a tebela e popula com os dados do device. 
        this.tableFormat(values,keys);
    }    
}
